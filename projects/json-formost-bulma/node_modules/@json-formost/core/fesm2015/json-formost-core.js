import { ɵɵdefineInjectable, Injectable } from '@angular/core';
import { of } from 'rxjs';
import { FormGroup as FormGroup$1, FormArray as FormArray$1, FormControl as FormControl$1, Validators } from '@angular/forms';

function populateInterfaceProperties(target, source, properties) {
    const allProps = ['name', 'refid', 'title', 'description', 'help', ...properties];
    for (const prop of allProps) {
        if (source.hasOwnProperty(prop)) {
            target[prop] = source[prop];
        }
    }
}
const ɵ0 = (a, b) => {
    return 0;
}, ɵ1 = (a, b) => {
    return a.value.localeCompare(b.value);
}, ɵ2 = (a, b) => {
    return a.key > b.key ? -1 : (b.key > a.key ? 1 : 0);
};
const keyValueSorters = {
    // Preserve original property order
    originalOrder: ɵ0,
    // Order by ascending property value
    valueAscOrder: ɵ1,
    // Order by descending property key
    keyDescOrder: ɵ2
};

class FormGroup extends FormGroup$1 {
    constructor(controls) {
        //super(controls, validatorOrOpts, asyncValidator);
        super(controls);
        this.controls = controls;
    }
    populate(source) {
        populateInterfaceProperties(this, source, []);
    }
    getControlType() {
        return 'group';
    }
}

class FormArray extends FormArray$1 {
    constructor(controls, validatorOrOpts, asyncValidator, fbs) {
        super(controls, validatorOrOpts, asyncValidator);
        this.controls = controls;
        this.fbs = fbs;
        this.itemTypes = [];
        this.additionalItems = false;
    }
    populate(source) {
        populateInterfaceProperties(this, source, ['uniqueItems', 'contains', 'additionalItems', 'minItems', 'maxItems']);
    }
    getControlType() {
        return 'array';
    }
    setValue(value, options = {}) {
        if (value && value.length > 0) {
            if (!this.fbs)
                throw 'Must supply FormBuilderService instance.';
            value.forEach(val => {
                const schema = this.itemTypes.length == 1
                    ? this.itemTypes[0]
                    : this.itemTypes.find(sch => sch.type == typeof val); // ToDo: better type matching
                // console.info("schema+val", schema, val);
                let ctl = this.fbs.getFormostAbstractControl(schema);
                this.push(ctl);
            });
        }
        super.setValue(value, options);
        // this._checkAllValuesPresent(value);
        // value.forEach((newValue: any, index: number) => {
        //   this._throwIfControlMissing(index);
        //   this.at(index).setValue(newValue, {onlySelf: true, emitEvent: options.emitEvent});
        // });
        // this.updateValueAndValidity(options);
    }
}

class FormControl extends FormControl$1 {
    constructor(source, formState) {
        super(formState, null, null);
        // type: string
        this.minLength = null;
        this.maxLength = null;
        this.pattern = null;
        this.contentMediaType = null;
        // type: number
        this.multipleOf = null;
        this.minimum = null;
        this.exclusiveMinimum = null;
        this.maximum = null;
        this.exclusiveMaximum = null;
        populateInterfaceProperties(this, source, ['type', 'required', 'enum', 'minLength', 'maxLength', 'pattern', 'format', 'contentEncoding', 'contentMediaType', 'multipleOf', 'minimum', 'exclusiveMinimum', 'maximum', 'exclusiveMaximum']);
        this.setValidators(this.getValidators());
    }
    get uiType() {
        if (this.type == 'string' && this.enum) {
            return 'dropdown';
        }
        if (this.type == 'boolean') {
            return 'checkbox';
        }
        // if (this.type == 'string' && (this.minLength > 99 || this.maxLength > 99)) { return 'bigtext'; }
        if (this.type == 'string' && this.contentMediaType == 'text/html') {
            return 'richtext';
        }
        if (this.type == 'string' && this.contentMediaType == 'text/markdown') {
            return 'markdown';
        }
        return 'input';
    }
    ;
    get inputType() {
        if (this.uiType == 'input') {
            if (this.type == 'number' || this.type == 'integer') {
                return 'number';
            }
            if (this.type == 'string' && this.format == 'date-time') {
                return 'datetime-local';
            }
            if (this.type == 'string' && this.format == 'date') {
                return 'date';
            }
            if (this.type == 'string' && this.format == 'time') {
                return 'number';
            }
            if (this.type == 'string' && this.format == 'email') {
                return 'email';
            }
            if (this.type == 'string' && this.format == 'uri') {
                return 'url';
            }
            if (this.type == 'string') {
                return 'text';
            }
        }
        return null;
    }
    populate(source) {
        populateInterfaceProperties(this, source, ['type', 'required', 'enum', 'minLength', 'maxLength', 'pattern', 'format', 'contentEncoding', 'contentMediaType', 'multipleOf', 'minimum', 'exclusiveMinimum', 'maximum', 'exclusiveMaximum']);
    }
    getControlType() {
        return 'control';
    }
    getValidators() {
        const validators = [];
        if (this.required)
            validators.push(Validators.required);
        if (this.type == 'string') {
            if (this.minLength !== null)
                validators.push(Validators.minLength(this.minLength));
            if (this.maxLength !== null)
                validators.push(Validators.minLength(this.maxLength));
            if (this.pattern !== null)
                validators.push(Validators.pattern(this.pattern));
            if (this.format == "email")
                validators.push(Validators.email);
        }
        if (this.type == 'number') {
            if (this.minimum !== null)
                validators.push(Validators.min(this.minimum));
            if (this.maximum !== null)
                validators.push(Validators.max(this.maximum));
        }
        console.info(name, validators);
        return validators;
    }
}

class SchemaConverterService {
    constructor() { }
    getFormostForm(schema) {
        let formItems = this.getFormItems(schema, "#");
        if (formItems instanceof FormGroup)
            return formItems;
        else {
            return new FormGroup({ formost: formItems });
        }
    }
    getFormostForm$(schema) {
        return of(this.getFormostForm(schema));
    }
    getFormostAbstractControl(schema, refId = "#") {
        let formItems = this.getFormItems(schema, refId);
        return formItems;
    }
    getFormostAbstractControl$(schema, refId = "#") {
        return of(this.getFormostAbstractControl(schema, refId));
    }
    getFormItems(schema, refId = "#") {
        const schemaObj = typeof schema === 'string' ? JSON.parse(schema) : schema;
        if (!schemaObj) {
            console.warn('NO-OBJECT', schemaObj);
            return {};
        }
        if (!schemaObj.type) {
            console.warn('NO-TYPE', schemaObj);
            return {};
        }
        let formItems;
        switch (schemaObj.type) {
            case 'null':
                return null;
            case 'object':
                formItems = this.getFormGroup(schemaObj, refId);
                break;
            case 'array':
                formItems = this.getFormArray(schemaObj, refId);
                break;
            default:
                formItems = this.getFormControl(schemaObj, refId);
                break;
        }
        return formItems;
    }
    getFormControl(obj, refId) {
        const formCtl = new FormControl(obj);
        // formCtl.populate(obj);
        if (refId) {
            formCtl.refid = refId;
        }
        return formCtl;
    }
    getFormGroup(obj, refId) {
        const reqArr = obj.required || [];
        const item = new FormGroup({});
        item.populate(obj);
        if (refId) {
            item.refid = refId;
        }
        for (const prop in obj.properties) {
            if (obj.properties.hasOwnProperty(prop)) {
                const unknownField = obj.properties[prop];
                unknownField.name = prop;
                if (reqArr.indexOf(prop) > -1) {
                    unknownField.required = true;
                }
                const knownField = this.getFormItems(unknownField, `${refId}/fields/${prop}`);
                //item.fields.push(knownField);
                item.addControl(prop, knownField);
            }
        }
        return item;
    }
    getFormArray(obj, refId) {
        const item = new FormArray([], undefined, undefined, this);
        item.populate(obj);
        if (refId) {
            item.refid = refId;
        }
        const allowedTypesArray = Array.isArray(obj.items)
            ? obj.items
            : [obj.items];
        // let i = 0;
        // for (const allowedType of allowedTypesArray) {
        //     // ++i;
        //     // allowedType.name = allowedType.name || `${obj.name ? obj.name + '-' : null}type-${i}`;
        //     // item.itemTypes.push(this.getFormItems(allowedType, `${refId}/itemTypes/${allowedType.name}`) as FormField);
        //     item.itemTypes.push(this.getFormItems(allowedType, `${refId}/itemTypes/[${i++}]`) as FormControl);
        // }
        item.itemTypes = allowedTypesArray;
        return item;
    }
}
SchemaConverterService.ɵprov = ɵɵdefineInjectable({ factory: function SchemaConverterService_Factory() { return new SchemaConverterService(); }, token: SchemaConverterService, providedIn: "root" });
SchemaConverterService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
SchemaConverterService.ctorParameters = () => [];

/**

var x: JSONSchema7 = {
    "title": "People",
    "type": "object",
    "properties": {
        "name": {
            "type": "string",
            "minLength": 3,
            "description": "Please enter your name"
        },
        "vegetarian": {
            "type": "boolean",
            "title": "Are you a vegetarian?"
        },
        "birthDate": {
            "type": "string",
            "format": "date"
        },
        "nationality": {
            "type": "string",
            "enum": [
                "DE",
                "IT",
                "JP",
                "US",
                "RU",
                "Other"
            ]
        },
        "favorites": {
            "type": "array",
            "items": {
                "type": "string"
            },
            "uniqueItems": true,
            "default": []
        },
        "personalData": {
            "type": "object",
            "properties": {
                "age": {
                    "type": "integer",
                    "description": "Please enter your age."
                },
                "height": {
                    "type": "number"
                },
                "drivingSkill": {
                    "type": "number",
                    "maximum": 10,
                    "minimum": 1,
                    "default": 7
                }
            },
            "required": [
                "age",
                "height"
            ]
        },
        "occupation": {
            "enum": [
                "doctor",
                "lawyer"
            ],
            "type": "string"
        },
        "postalCode": {
            "type": "string",
            "maxLength": 5
        }
    },
    "required": [
        "occupation",
        "nationality"
    ]
};


// */

/*
 * Public API Surface of json-formost-core
 */

/**
 * Generated bundle index. Do not edit.
 */

export { FormArray, FormControl, FormGroup, SchemaConverterService, keyValueSorters, populateInterfaceProperties, ɵ0, ɵ1, ɵ2 };
//# sourceMappingURL=json-formost-core.js.map
